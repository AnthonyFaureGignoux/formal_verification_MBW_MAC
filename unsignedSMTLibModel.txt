;Formalization of the architecture with unsigned integer number representation

;Extend 8 bits to unsigned 32 bits
(define-fun ext8ToU32 ((x (_ BitVec 8) )) (_ BitVec 32)
    ((_ zero_extend 24) x)
)
;Extend 8 bits to unsigned 16 bits
(define-fun ext8ToU16 ((x (_ BitVec 8) )) (_ BitVec 16)
    ((_ zero_extend 8) x)
)

;Extend 16 bits to unsigned 32 bits
(define-fun ext16ToU32 ((x (_ BitVec 16) )) (_ BitVec 32)
    ((_ zero_extend 16) x)

;Perform the 32 bit multiplication of two 8 bit numbers
(define-fun mul32 
    (
        (x (_ BitVec 8))
        (y (_ BitVec 8))
    )
    (_ BitVec 32)
    (bvmul (ext8ToU32 x) (ext8ToU32 y))
)

;Full precision formalization implementing the decomposed multiplication of two 16 bit numbers
;a * b = (a_h * 2^8 + a_l) * (b_h * 2^8 + b_l) = a_h * b_h * 2^16 + (a_h * b_l + a_l * b_h) * 2^8 + a_l * b_l
(define-fun FP 
    (
        (a_h (_ BitVec 8))
        (a_l (_ BitVec 8))
        (b_h (_ BitVec 8))
        (b_l (_ BitVec 8))
    )
    (_ BitVec 32)
    (bvadd 
        (bvshl (mul32 a_h b_h) #x00000010)
        (bvshl 
            (bvadd (mul32 a_h b_l) (mul32 a_l b_h)) 
            #x00000008 )
        (mul32 a_l b_l)
    )
)

;Half precision formalization implementing the parallel compuration without subword switching 
(define-fun HP_NSP 
    (
        (a_h (_ BitVec 8))
        (a_l (_ BitVec 8))
        (b_h (_ BitVec 8))
        (b_l (_ BitVec 8))
    )
    (_ BitVec 32)
    (bvadd 
        (bvshl (mul32 a_h b_h) #x00000010)
        (bvmul (ext8ToU32 a_l) (ext8ToU32 b_l))
    )
)

;Half precision formalization implementing the parallel compuration subword switching
(define-fun HP_SP 
    (
        (a_h (_ BitVec 8))
        (a_l (_ BitVec 8))
        (b_h (_ BitVec 8))
        (b_l (_ BitVec 8))
    )
    (_ BitVec 32)
    (bvadd 
        (bvshl (mul32 b_h a_l) #x00000010)
        (bvmul (ext8ToU32 a_h) (ext8ToU32 b_l))
    )
)

;Define a multiplier on unsigned 8-bits with enabling capability 
(define-fun M
    (
        (a (_ BitVec 8))
        (b (_ BitVec 8))
        (e Bool)
    )
    (_ BitVec 16)
    (ite e (bvmul (ext8ToU16 a) (ext8ToU16 b)) #x0000)
)

;Define the switching logic for a_1
(define-fun a_1 
    (
        (a_h (_ BitVec 8))
        (a_l (_ BitVec 8))
        (SP Bool)
    )
    (_ BitVec 8)
    (ite SP a_l a_h)
)

;Define the switching logic for a_0
(define-fun a_0 
    (
        (a_h (_ BitVec 8))
        (a_l (_ BitVec 8))
        (SP Bool)
    )
    (_ BitVec 8)
    (ite SP a_h a_l)
)

;Define the switching logic for b_1 => None here, but can be considered in an extension
(define-fun b_1 
    (
        (b_h (_ BitVec 8))
        (b_l (_ BitVec 8))
        (SP Bool)
    )
    (_ BitVec 8)
    b_h
)

;Define the switching logic for b_0 => None here, but can be considered in an extension
(define-fun b_0 
    (
        (b_h (_ BitVec 8))
        (b_l (_ BitVec 8))
        (SP Bool)
    )
    (_ BitVec 8)
    b_l
)

;Define the computation of M_l w.r.t. the INV configuration and the M_00, M_10 results 
(define-fun M_l 
    (
        (M_00_r (_ BitVec 16))
        (M_10_r (_ BitVec 16))
        (INV Bool)
    )
    (_ BitVec 32)
    (ite INV (ext16ToU32 M_10_r) (ext16ToU32 M_00_r))
)

;Define the computation of M_h w.r.t. the INV configuration and the M_01, M_11 results 
(define-fun M_h 
    (
        (M_01_r (_ BitVec 16))
        (M_11_r (_ BitVec 16))
        (INV Bool)
    )
    (_ BitVec 32)
    (ite INV (ext16ToU32 M_01_r) (ext16ToU32 M_11_r))
)

;Define the computation of M_m w.r.t. the INV configuration and the fours multipliers results 
(define-fun M_m
    (
        (M_00_r (_ BitVec 16))
        (M_01_r (_ BitVec 16))
        (M_10_r (_ BitVec 16))
        (M_11_r (_ BitVec 16))
        (INV Bool)
    )
    (_ BitVec 32)
    (ite INV 
        (bvadd (ext16ToU32 M_11_r) (ext16ToU32 M_00_r))
        (bvadd (ext16ToU32 M_10_r) (ext16ToU32 M_01_r))
    )
)

;Define the final computation of the 32-bits results using the formula
;M_r = M_h * 2^16 + M_m * 2^8 + M_l
(define-fun M_r 
    (
        (M_h_r (_ BitVec 32))
        (M_m_r (_ BitVec 32))
        (M_l_r (_ BitVec 32))
    )
    (_ BitVec 32)
    (bvadd 
        (bvshl M_h_r #x00000010)
        (bvshl M_m_r #x00000008)
        M_l_r
    )
)

;building MBWMAC circuit
(define-fun MBWMAC
    (
        (a_h (_ BitVec 8))
        (a_l (_ BitVec 8))
        (b_h (_ BitVec 8))
        (b_l (_ BitVec 8))
        (INV Bool)
        (e_00 Bool)
        (e_01 Bool)
        (e_10 Bool)
        (e_11 Bool)
        (SP Bool)
    )
    (_ BitVec 32)
    (let 
        (
            (M_00 
                (M
                    (a_0 a_h a_l SP)
                    (b_0 b_h b_l SP)
                    e_00
                )
            )
            (M_01 
                (M
                    (a_0 a_h a_l SP)
                    (b_1 b_h b_l SP)
                    e_01
                )
            )
            (M_10 
                (M
                    (a_1 a_h a_l SP)
                    (b_0 b_h b_l SP)
                    e_10
                )
            )
            (M_11 
                (M
                    (a_1 a_h a_l SP)
                    (b_1 b_h b_l SP)
                    e_11
                )
            )
        )
        (M_r
            (M_h M_01 M_11 INV)
            (M_m M_00 M_01 M_10 M_11 INV)
            (M_l M_00 M_10 INV)
        )
    )
)

;Declare any bitvector 
(declare-const a_h (_ BitVec 8))
(declare-const a_l (_ BitVec 8))
(declare-const b_h (_ BitVec 8))
(declare-const b_l (_ BitVec 8))

;Declare any conf
(declare-const INV Bool)
(declare-const e_00 Bool)
(declare-const e_01 Bool)
(declare-const e_10 Bool)
(declare-const e_11 Bool)
(declare-const SP Bool)

;Instanciate circuit
(define-const result (_ BitVec 32) 
    (MBWMAC a_h a_l b_h b_l INV e_00 e_01 e_10 e_11 SP)
)

;Define the configuration in nominal situation
(define-const nominalMainConf Bool 
    (and e_00 e_11 (not INV))
)

;Define the configuration for nominal FP
(define-const nominalFPConf Bool 
    (and (not SP) e_10 e_01)
)

;Define the configuration for nonminal HP_NSP
(define-const nominalHP_NSPConf Bool
    (and (not SP) (not e_01) (not e_10))
)

;Define the configuration for nominal HP_SP
(define-const nominalHP_SPConf Bool
    (and SP (not e_01) (not e_10))
)

(echo "[INFO] Analysis in the nominal case for unsigned integer")
(push)
(assert nominalMainConf)

; testing configuration for FP
(push)
(assert nominalFPConf)

; testing a particular example
(push)
(assert (= a_h #x33))
(assert (= a_l #xCC))
(assert (= b_h #x42))
(assert (= b_l #x18))

(assert (= (a_1 a_h a_l SP) #x33))
(assert (= (a_0 a_h a_l SP) #xCC))
(assert (= (b_1 b_h b_l SP) #x42))
(assert (= (b_0 b_h b_l SP) #x18))

(assert 
    (= 
        (M
            (a_0 a_h a_l SP)
            (b_0 b_h b_l SP)
            e_00
        )
        #x1320
    )
)

(assert 
    (= 
        (M
            (a_0 a_h a_l SP)
            (b_1 b_h b_l SP)
            e_01
        )
        #x3498
    )
)

(assert 
    (= 
        (M
            (a_1 a_h a_l SP)
            (b_0 b_h b_l SP)
            e_10
        )
        #x04C8
    )
)

(assert 
    (= 
        (M
            (a_1 a_h a_l SP)
            (b_1 b_h b_l SP)
            e_11
        )
        #x0D26
    )
)

(assert (= (M_l #x1320 #x04C8 INV) #x00001320))
(assert (= (M_h #x3498 #x0D26 INV) #x00000D26))
(assert (= (M_m #x1320 #x3498 #x04C8 #x0D26 INV) #x00003960))

(assert (= (M_r #x00000D26 #x00003960 #x00001320) #x0D5F7320))

(assert (= result #x0D5F7320))

(assert (= result (FP a_h a_l b_h b_l)))

(echo "[INFO] Trying FP on a valid example, should be SAT and it is: ")
(check-sat) 
; going back to general case example should be UNSAT
(pop)
(push)

(assert (not (= result (FP a_h a_l b_h b_l))))
(echo "[INFO] Proving that the configuration is equivalent to FP, should be UNSAT and it is: ")
(check-sat) 
(pop) ;remove soudness proof assertion
(pop) ;going out of FP mode

; moving to nominal HP_NSP 
(push)
(assert nominalHP_NSPConf)

; testing a particular example
(push)
(assert (= a_h #x33))
(assert (= a_l #xCC))
(assert (= b_h #x42))
(assert (= b_l #x18))

(assert (= (a_1 a_h a_l SP) #x33))
(assert (= (a_0 a_h a_l SP) #xCC))
(assert (= (b_1 b_h b_l SP) #x42))
(assert (= (b_0 b_h b_l SP) #x18))

(assert 
    (= 
        (M
            (a_0 a_h a_l SP)
            (b_0 b_h b_l SP)
            e_00
        )
        #x1320
    )
)

(assert 
    (= 
        (M
            (a_0 a_h a_l SP)
            (b_1 b_h b_l SP)
            e_01
        )
        #x0000
    )
)

(assert 
    (= 
        (M
            (a_1 a_h a_l SP)
            (b_0 b_h b_l SP)
            e_10
        )
        #x0000
    )
)

(assert 
    (= 
        (M
            (a_1 a_h a_l SP)
            (b_1 b_h b_l SP)
            e_11
        )
        #x0D26
    )
)

(assert (= (M_l #x1320 #x0000 INV) #x00001320))
(assert (= (M_h #x0000 #x0D26 INV) #x00000D26))
(assert (= (M_m #x1320 #x0000 #x0000 #x0D26 INV) #x00000000))

(assert (= (M_r #x00000D26 #x00000000 #x00001320) #x0D261320))

(assert (= result #x0D261320))

(assert (= result (HP_NSP a_h a_l b_h b_l)))

(echo "[INFO] Trying HP_NSP on a valid example, should be SAT and it is: ")
(check-sat)

; going back to general case
(pop)
(push)

(assert (not (= result (HP_NSP a_h a_l b_h b_l))))

(echo "[INFO] Proving that the configuration is equivalent to HP_NSP, should be UNSAT and it is: ")
(check-sat)
(pop) ;remove soudness proof assertion
(pop) ;going out of HP_NSP mode

; moving to nominal HF_SP 
(push)
(assert nominalHP_SPConf)

; testing a particular example
(push)
(assert (= a_h #x33))
(assert (= a_l #xCC))
(assert (= b_h #x42))
(assert (= b_l #x18))

(assert (= (a_1 a_h a_l SP) #xCC))
(assert (= (a_0 a_h a_l SP) #x33))
(assert (= (b_1 b_h b_l SP) #x42))
(assert (= (b_0 b_h b_l SP) #x18))

(assert 
    (= 
        (M
            (a_0 a_h a_l SP)
            (b_0 b_h b_l SP)
            e_00
        )
        #x04C8
    )
)

(assert 
    (= 
        (M
            (a_0 a_h a_l SP)
            (b_1 b_h b_l SP)
            e_01
        )
        #x0000
    )
)

(assert 
    (= 
        (M
            (a_1 a_h a_l SP)
            (b_0 b_h b_l SP)
            e_10
        )
        #x0000
    )
)

(assert 
    (= 
        (M
            (a_1 a_h a_l SP)
            (b_1 b_h b_l SP)
            e_11
        )
        #x3498
    )
)

(assert (= (M_l #x04C8 #x0000 INV) #x000004C8))
(assert (= (M_h #x0000 #x3498 INV) #x00003498))
(assert (= (M_m #x04C8 #x0000 #x0000 #x3498 INV) #x00000000))

(assert (= (M_r #x00003498 #x00000000 #x000004C8) #x349804C8))

(assert (= result #x349804C8))

(assert (= result (HP_SP a_h a_l b_h b_l)))

(echo "[INFO] Trying HP_SP on a valid example, should be SAT and it is: ")
(check-sat)

(pop); going back to general case
(push)

(assert (not (= result (HP_SP a_h a_l b_h b_l))))

(echo "[INFO] Proving that the configuration is equivalent to HP_SP, should be UNSAT and it is: ")
(check-sat) ; UNSAT => :-)
(pop) ;remove soudness proof assertion
(pop) ;going out of HP_NSP mode
(pop) ;going out of nominal mode

(echo "[INFO] Check in faulty case")
(push) ; test in faulty case
(declare-const faulty (_ BitVec 2)) ; identify which one is faulty
(assert
    (ite (= faulty #b00) (not e_00)
        (ite (= faulty #b01) (not e_01)
            (ite (= faulty #b10) (not e_10)
                (not e_11)
            )
        )    
    )
)

(push) ;checking HP when the diag are ok
(assert (or (= faulty #b01) (= faulty #b10)))
; configure like nominal
(assert nominalMainConf)
(push) ;going to HP_NSP
(assert nominalHP_NSPConf)
(assert (not (= result (HP_NSP a_h a_l b_h b_l))))

(echo "[INFO] When non diag unit is faulty proving that computation is equivalent to HP_NSP, should be UNSAT and it is: ")
(check-sat) 
(pop) ;remove soudness proof assertion
(push) ;going to HP_SP
(assert nominalHP_SPConf)
(assert (not (= result (HP_SP a_h a_l b_h b_l))))

(echo "[INFO] When non diag unit is faulty proving that computation is equivalent to HP_SP, should be UNSAT and it is: ")
(check-sat) ; UNSAT => :-)
(pop) ;remove soudness proof assertion
(pop) ;remove the diag are ok assumption
(push) ;checking HP when the diag are not ok
(assert (or (= faulty #b00) (= faulty #b11)))

(push) ;going to HP_NSP
(assert INV)
(assert SP)
(assert e_01)
(assert e_10)
(assert (not e_00))
(assert (not e_11))

(assert (not (= result (HP_NSP a_h a_l b_h b_l))))

(echo "[INFO] When diag unit is faulty proving that computation is equivalent to HP_NSP, should be UNSAT and it is: ")
(check-sat) ; UNSAT => :-)
(pop) ;remove soudness proof assertion
(push) ;going to HP_SP
(assert INV)
(assert (not SP))
(assert e_01)
(assert e_10)
(assert (not e_00))
(assert (not e_11))
(assert (not (= result (HP_SP a_h a_l b_h b_l))))

(echo "[INFO] When non diag unit is faulty proving that computation is equivalent to HP_SP, should be UNSAT and it is: ")
(check-sat) ; UNSAT => :-)
(pop) ;remove soudness proof assertion
(pop) ;remove the diag are ok assumption

; compute the first element for FP
(assert (not INV))
(assert (not SP))
(assert (implies (not (= faulty #b00)) e_00))
(assert (implies (not (= faulty #b01)) e_01))
(assert (implies (not (= faulty #b10)) e_10))
(assert (implies (not (= faulty #b11)) e_11))

;compute the second element for FP with
(define-const INV2 Bool (not INV))
(define-const SP2 Bool (not SP))
(define-const e2_00 Bool (= faulty #b10))
(define-const e2_01 Bool (= faulty #b11))
(define-const e2_10 Bool (= faulty #b00))
(define-const e2_11 Bool (= faulty #b01))

(define-const result2 (_ BitVec 32) 
    (MBWMAC a_h a_l b_h b_l INV2 e2_00 e2_01 e2_10 e2_11 SP2)
)

(echo "[INFO] When a unit is faulty proving that computation is equivalent to FP")
;(assert (not (= (bvadd result result2) (FP a_h a_l b_h b_l)))) ; => to difficult check simpler property
(echo "[INFO] The first computation is correct when M00 is faulty, should be UNSAT and it is:")
(push)
(assert (= faulty #b00)) 
(assert 
   (not 
        (= 
            (FP a_h a_l b_h b_l) 
            (bvadd result (bvmul (ext8ToU32 a_l) (ext8ToU32 b_l)))
        )
    )
)  
(check-sat) ; 
(pop)
(echo "[INFO] The second computation is correct when M00 is faulty, should be UNSAT and it is:")
(push)
(assert (= faulty #b00)) 
(assert 
    (not 
        (= 
            result2 
            (bvmul (ext8ToU32 a_l) (ext8ToU32 b_l))
        )
    )
)  
(check-sat) ; 
(pop)
(echo "[INFO] The first computation is correct when M01 is faulty, should be UNSAT and it is:")
(push)
(assert (= faulty #b01)) 
(assert 
    (not 
        (= 
            (FP a_h a_l b_h b_l) 
            (bvadd result (bvshl (bvmul (ext8ToU32 a_l) (ext8ToU32 b_h)) #x00000008))
        )
    )
) 
(check-sat) ; 
(pop)
(echo "[INFO] The second computation is correct when M01 is faulty, should be UNSAT and it is:")
(push)
(assert (= faulty #b01)) 
(assert 
    (not 
        (= 
            result2 
            (bvshl (bvmul (ext8ToU32 a_l) (ext8ToU32 b_h)) #x00000008)
        )
    )
)  
(check-sat) ; 
(pop)

(echo "[INFO] The first computation is correct when M10 is faulty, should be UNSAT and it is:")
(push)
(assert (= faulty #b10))
(assert 
    (not 
        (= 
            (FP a_h a_l b_h b_l) 
            (bvadd result (bvshl (bvmul (ext8ToU32 a_h) (ext8ToU32 b_l)) #x00000008))
        )
    )
) 
(check-sat) ; 
(pop)

(echo "[INFO] The second computation is correct when M10 is faulty, should be UNSAT and it is:")
(push)
(assert (= faulty #b10)) 
(assert 
    (not 
        (= 
            result2 
            (bvshl (bvmul (ext8ToU32 a_h) (ext8ToU32 b_l)) #x00000008)
        )
    )
)  
(check-sat) ; 
(pop)

(echo "[INFO] The first computation is correct when M11 is faulty, should be UNSAT and it is:")
(push)
(assert (= faulty #b11)) 
(assert 
    (not 
        (= 
            (FP a_h a_l b_h b_l) 
            (bvadd result (bvshl (bvmul (ext8ToU32 a_h) (ext8ToU32 b_h)) #x00000010))
        )
    )
)
(check-sat)
(pop)

(echo "[INFO] The second computation is correct when M11 is faulty, should be UNSAT and it is:")
(push)
(assert (= faulty #b11)) 
(assert 
    (not 
        (= 
            result2 
            (bvshl (bvmul (ext8ToU32 a_h) (ext8ToU32 b_h)) #x00000010)
        )
    )
)  
(check-sat) ; 
(pop)