(define-fun ext8ToU32 ((x (_ BitVec 8) )) (_ BitVec 32)
    ((_ zero_extend 24) x)
)

(define-fun ext8ToU16 ((x (_ BitVec 8) )) (_ BitVec 16)
    ((_ zero_extend 8) x)
)

(define-fun ext16ToU32 ((x (_ BitVec 16) )) (_ BitVec 32)
    ((_ zero_extend 16) x)
)

(define-fun ext8ToS32 ((x (_ BitVec 8) )) (_ BitVec 32)
    ((_ sign_extend 24) x)
)

(define-fun ext8ToS16 ((x (_ BitVec 8) )) (_ BitVec 16)
    ((_ sign_extend 8) x)
)

(define-fun ext16ToS32 ((x (_ BitVec 16) )) (_ BitVec 32)
    ((_ sign_extend 16) x)
)

(define-fun mul32 
    (
        (x (_ BitVec 8))
        (y (_ BitVec 8))
        (xSigned Bool)
        (ySigned Bool)
    )
    (_ BitVec 32)
    (bvmul
        (ite xSigned (ext8ToS32 x) (ext8ToU32 x))
        (ite ySigned (ext8ToS32 y) (ext8ToU32 y))
    )
)

(define-fun mul16
    (
        (x (_ BitVec 8))
        (y (_ BitVec 8))
        (xSigned Bool)
        (ySigned Bool)
    )
    (_ BitVec 16)
    (bvmul
        (ite xSigned (ext8ToS16 x) (ext8ToU16 x))
        (ite ySigned (ext8ToS16 y) (ext8ToU16 y))
    )
)

(define-fun FP 
    (
        (a_h (_ BitVec 8))
        (a_l (_ BitVec 8))
        (b_h (_ BitVec 8))
        (b_l (_ BitVec 8))
    )
    (_ BitVec 32)
    (bvadd 
        (bvshl (mul32 a_h b_h true true) #x00000010)
        (bvshl 
            (bvadd (mul32 a_h b_l true false) (mul32 a_l b_h false true))
            #x00000008 )
        (mul32 a_l b_l false false)
    )
)

(define-fun HP_NSP 
    (
        (a_h (_ BitVec 8))
        (a_l (_ BitVec 8))
        (b_h (_ BitVec 8))
        (b_l (_ BitVec 8))
    )
    (_ BitVec 32)
    (bvadd 
        (bvshl (mul32 a_h b_h true true) #x00000010)
        (ext16ToU32 (mul16 a_l b_l true true))
    )
)

(define-fun HP_SP 
    (
        (a_h (_ BitVec 8))
        (a_l (_ BitVec 8))
        (b_h (_ BitVec 8))
        (b_l (_ BitVec 8))
    )
    (_ BitVec 32)
    (bvadd 
        (bvshl (mul32 b_h a_l true true) #x00000010)
        (ext16ToU32 (mul16 a_h b_l true true))
    )
)

(define-fun M
    (
        (a (_ BitVec 8))
        (b (_ BitVec 8))
        (e Bool)
        (aSigned Bool)
        (bSigned Bool)
    )
    (_ BitVec 16)
    (ite e (mul16 a b aSigned bSigned) #x0000)
)

(define-fun a_1 
    (
        (a_h (_ BitVec 8))
        (a_l (_ BitVec 8))
        (SP Bool)
    )
    (_ BitVec 8)
    (ite SP a_l a_h)
)

(define-fun a_0 
    (
        (a_h (_ BitVec 8))
        (a_l (_ BitVec 8))
        (SP Bool)
    )
    (_ BitVec 8)
    (ite SP a_h a_l)
)

(define-fun b_1 
    (
        (b_h (_ BitVec 8))
        (b_l (_ BitVec 8))
        (SP Bool)
    )
    (_ BitVec 8)
    b_h
)

(define-fun b_0 
    (
        (b_h (_ BitVec 8))
        (b_l (_ BitVec 8))
        (SP Bool)
    )
    (_ BitVec 8)
    b_l
)

(define-fun M_l 
    (
        (M_00_r (_ BitVec 16))
        (M_10_r (_ BitVec 16))
        (INV Bool)
    )
    (_ BitVec 32)
    (ext16ToU32 (ite INV M_10_r M_00_r))
)

(define-fun M_h 
    (
        (M_01_r (_ BitVec 16))
        (M_11_r (_ BitVec 16))
        (INV Bool)
    )
    (_ BitVec 32)
    (ext16ToS32 (ite INV M_01_r M_11_r))
)

(define-fun M_m
    (
        (M_00_r (_ BitVec 16))
        (M_01_r (_ BitVec 16))
        (M_10_r (_ BitVec 16))
        (M_11_r (_ BitVec 16))
        (INV Bool)
    )
    (_ BitVec 32)
    (ite INV 
        (bvadd (ext16ToS32 M_11_r) (ext16ToS32 M_00_r))
        (bvadd (ext16ToS32 M_10_r) (ext16ToS32 M_01_r))
    )
)

(define-fun M_r 
    (
        (M_h_r (_ BitVec 32))
        (M_m_r (_ BitVec 32))
        (M_l_r (_ BitVec 32))
    )
    (_ BitVec 32)
    (bvadd 
        (bvshl M_h_r #x00000010)
        (bvshl M_m_r #x00000008)
        M_l_r
    )
)

(define-fun isHPMode
    (
        (w Bool)
        (x Bool)
        (y Bool)
        (z Bool)
    )
    Bool
    ((_ pbeq 2 1 1 1 1) w x y z)
)

;building circuit

(define-fun MBWMAC
    (
        (a_h (_ BitVec 8))
        (a_l (_ BitVec 8))
        (b_h (_ BitVec 8))
        (b_l (_ BitVec 8))
        (INV Bool)
        (e_00 Bool)
        (e_01 Bool)
        (e_10 Bool)
        (e_11 Bool)
        (SP Bool)
    )
    (_ BitVec 32)
    (let 
        (
            (M_00 
                (M
                    (a_0 a_h a_l SP)
                    (b_0 b_h b_l SP)
                    e_00
                    (or (isHPMode e_00 e_01 e_10 e_11) SP) ;signed in HP mode or in FP and SP (since a_0 = a_h)
                    (isHPMode e_00 e_01 e_10 e_11) ;signed only in HP mode
                )
            )
            (M_01 
                (M
                    (a_0 a_h a_l SP)
                    (b_1 b_h b_l SP)
                    e_01
                    (or (isHPMode e_00 e_01 e_10 e_11) SP) ;signed in HP mode or in FP and SP (since a_0 = a_h)
                    true ; always true since b_1 = b_h
                )
            )
            (M_10 
                (M
                    (a_1 a_h a_l SP)
                    (b_0 b_h b_l SP)
                    e_10
                    (or (isHPMode e_00 e_01 e_10 e_11) (not SP)) ;signed in HP mode or in FP and not SP
                    (isHPMode e_00 e_01 e_10 e_11) ;signed only in HP mode
                )
            )
            (M_11 
                (M
                    (a_1 a_h a_l SP)
                    (b_1 b_h b_l SP)
                    e_11
                    (or (isHPMode e_00 e_01 e_10 e_11) (not SP)) ;signed in HP mode or in FP and not SP
                    true ; always true since b_1 = b_h
                )
            )
        )
        (M_r
            (M_h M_01 M_11 INV)
            (M_m M_00 M_01 M_10 M_11 INV)
            (M_l M_00 M_10 INV)
        )
    )
)

; declare any bitvector 
(declare-const a_h (_ BitVec 8))
(declare-const a_l (_ BitVec 8))
(declare-const b_h (_ BitVec 8))
(declare-const b_l (_ BitVec 8))

; declare any conf
(declare-const INV Bool)
(declare-const e_00 Bool)
(declare-const e_01 Bool)
(declare-const e_10 Bool)
(declare-const e_11 Bool)
(declare-const SP Bool)

; instanciate circuit

(define-const result (_ BitVec 32) 
    (MBWMAC a_h a_l b_h b_l INV e_00 e_01 e_10 e_11 SP)
)

; util constant
(define-const nominalMainConf Bool 
    (and e_00 e_11 (not INV))
)

(define-const nominalFPConf Bool 
    (and (not SP) e_10 e_01)
)

(define-const nominalHP_NSPConf Bool
    (and (not SP) (not e_01) (not e_10))
)

(define-const nominalHP_SPConf Bool
    (and SP (not e_01) (not e_10))
)

(echo "[INFO] Analysis in the nominal case for unsigned integer")
; testing nominal case
(push)
(assert nominalMainConf)

; testing configuration for FP
(push)
(assert nominalFPConf)

; testing a particular example
(push)
(assert (= a_h #x33))
(assert (= a_l #xCC))
(assert (= b_h #x42))
(assert (= b_l #x18))

(assert (= (a_1 a_h a_l SP) #x33))
(assert (= (a_0 a_h a_l SP) #xCC))
(assert (= (b_1 b_h b_l SP) #x42))
(assert (= (b_0 b_h b_l SP) #x18))

(assert (= (M_l #x1320 #x04C8 INV) #x00001320))
(assert (= (M_h #x3498 #x0D26 INV) #x00000D26))
(assert (= (M_m #x1320 #x3498 #x04C8 #x0D26 INV) #x00003960))

(assert (= (M_r #x00000D26 #x00003960 #x00001320) #x0D5F7320))

(assert (= result #x0D5F7320))

(assert (= result (FP a_h a_l b_h b_l)))

(echo "[INFO] Trying FP on a valid example, should be SAT and it is: ")
;(check-sat) 
; going back to general case example should be UNSAT
(pop)
(push)

(assert (not (= result (FP a_h a_l b_h b_l))))
(echo "[INFO] Proving that the configuration is equivalent to FP, should be UNSAT and it is: ")
;(check-sat)
(pop) ;remove soudness proof assertion
(pop) ;going out of FP mode

; moving to nominal HP_NSP 
(push)
(assert nominalHP_NSPConf)

; testing a particular example
(push)
(assert (= a_h #x33))
(assert (= a_l #xCC))
(assert (= b_h #x42))
(assert (= b_l #x18))

(assert (= (a_1 a_h a_l SP) #x33))
(assert (= (a_0 a_h a_l SP) #xCC))
(assert (= (b_1 b_h b_l SP) #x42))
(assert (= (b_0 b_h b_l SP) #x18))

(assert (= (M_l #xFB20 #x0000 INV) #x0000FB20))
(assert (= (M_h #x0000 #x0D26 INV) #x00000D26))
(assert (= (M_m #xFB20 #x0000 #x0000 #x0D26 INV) #x00000000))

(assert (= (M_r #x00000D26 #x00000000 #x0000FB20) #x0D26FB20))

(assert (= result #x0D26FB20))

(assert (= result (HP_NSP a_h a_l b_h b_l)))

(echo "[INFO] Trying HP_NSP on a valid example, should be SAT and it is: ")
;(check-sat)

; going back to general case
(pop)
(push)

(assert (not (= result (HP_NSP a_h a_l b_h b_l))))

(echo "[INFO] Proving that the configuration is equivalent to HP_NSP, should be UNSAT and it is: ")
;(check-sat)
(pop) ;remove soudness proof assertion
(pop) ;going out of HP_NSP mode

; moving to nominal HF_SP 
(push)
(assert nominalHP_SPConf)

; testing a particular example
(push)
(assert (= a_h #x33))
(assert (= a_l #xCC))
(assert (= b_h #x42))
(assert (= b_l #x18))

(assert (= (a_1 a_h a_l SP) #xCC))
(assert (= (a_0 a_h a_l SP) #x33))
(assert (= (b_1 b_h b_l SP) #x42))
(assert (= (b_0 b_h b_l SP) #x18))

(assert (= (M_l #x04C8 #x0000 INV) #x000004C8))
(assert (= (M_h #x0000 #xF298 INV) #xFFFFF298))
(assert (= (M_m #x04C8 #x0000 #x0000 #x3498 INV) #x00000000))

(assert (= (M_r #xFFFFF298 #x00000000 #x000004C8) #xF29804C8))

(assert (= result #xF29804C8))

(assert (= result (HP_SP a_h a_l b_h b_l)))

(echo "[INFO] Trying HP_SP on a valid example, should be SAT and it is: ")
;(check-sat)

(pop); going back to general case
(push)

(assert (not (= result (HP_SP a_h a_l b_h b_l))))

(echo "[INFO] Proving that the configuration is equivalent to HP_SP, should be UNSAT and it is: ")
;(check-sat) ; UNSAT => :-)
(pop) ;remove soundness proof assertion
(pop) ;going out of HP_NSP mode
(pop) ;going out of nominal mode

(echo "[INFO] Check in faulty case")
(push) ; test in faulty case
(declare-const faulty (_ BitVec 2)) ; identify which one is faulty
(assert
    (ite (= faulty #b00) (not e_00)
        (ite (= faulty #b01) (not e_01)
            (ite (= faulty #b10) (not e_10)
                (not e_11)
            )
        )    
    )
)

(push) ;checking HP when the diag are ok
(assert (or (= faulty #b01) (= faulty #b10)))
; configure like nominal
(assert nominalMainConf)
(push) ;going to HP_NSP
(assert nominalHP_NSPConf)

(push) ;testing a specific case
(assert (= a_h #x33))
(assert (= a_l #xCC))
(assert (= b_h #x42))
(assert (= b_l #x18))
(assert (= result (HP_NSP a_h a_l b_h b_l)))
(echo "[INFO] When non diag unit is faulty test the computation of HP_NSP on a specific example, should be SAT and it is: ")
;(check-sat)
(pop) ;going back to general case

(assert (not (= result (HP_NSP a_h a_l b_h b_l))))

(echo "[INFO] When non diag unit is faulty proving that computation is equivalent to HP_NSP, should be UNSAT and it is: ")
;(check-sat) 
(pop) ;remove soundness proof assertion
(push) ;going to HP_SP
(assert nominalHP_SPConf)

(push) ;testing a specific case
(assert (= a_h #x33))
(assert (= a_l #xCC))
(assert (= b_h #x42))
(assert (= b_l #x18))
(assert (= result (HP_SP a_h a_l b_h b_l)))
(echo "[INFO] When non diag unit is faulty test the computation of HP_SP on a specific example, should be SAT and it is: ")
;(check-sat)
(pop) ;going back to general case

(assert (not (= result (HP_SP a_h a_l b_h b_l))))

(echo "[INFO] When non diag unit is faulty proving that computation is equivalent to HP_SP, should be UNSAT and it is: ")
;(check-sat) ; UNSAT => :-)
(pop) ;remove soundness proof assertion
(pop) ;remove the diag are ok assumption


(push) ;checking HP when the diag are not ok
(assert (or (= faulty #b00) (= faulty #b11)))

(push) ;going to HP_NSP
(assert INV)
(assert SP)
(assert e_01)
(assert e_10)
(assert (not e_00))
(assert (not e_11))

(push) ;testing a specific case
(assert (= a_h #x33))
(assert (= a_l #xCC))
(assert (= b_h #x42))
(assert (= b_l #x18))
(assert (= result (HP_NSP a_h a_l b_h b_l)))
(echo "[INFO] When diag unit is faulty test the computation of HP_NSP on a specific example, should be SAT and it is: ")
;(check-sat)
(pop) ;going back to general case

(assert (not (= result (HP_NSP a_h a_l b_h b_l))))

(echo "[INFO] When diag unit is faulty proving that computation is equivalent to HP_NSP, should be UNSAT and it is: ")
;(check-sat) ; UNSAT => :-)
(pop) ;remove soudness proof assertion
(push) ;going to HP_SP
(assert INV)
(assert (not SP))
(assert e_01)
(assert e_10)
(assert (not e_00))
(assert (not e_11))

(push) ;testing a specific case
(assert (= a_h #x33))
(assert (= a_l #xCC))
(assert (= b_h #x42))
(assert (= b_l #x18))
(assert (= result (HP_SP a_h a_l b_h b_l)))
(echo "[INFO] When diag unit is faulty test the computation of HP_SP on a specific example, should be SAT and it is: ")
;(check-sat)
(pop) ;going back to general case

(assert (not (= result (HP_SP a_h a_l b_h b_l))))

(echo "[INFO] When non diag unit is faulty proving that computation is equivalent to HP_SP, should be UNSAT and it is: ")
;(check-sat) ; UNSAT => :-)
(pop) ;remove soudness proof assertion
(pop) ;remove the diag are ok assumption

; compute the first element for FP
(assert (not INV))
(assert (not SP))
(assert (implies (not (= faulty #b00)) e_00))
(assert (implies (not (= faulty #b01)) e_01))
(assert (implies (not (= faulty #b10)) e_10))
(assert (implies (not (= faulty #b11)) e_11))

;compute the second element for FP with
(define-const INV2 Bool (not INV))
(define-const SP2 Bool (not SP))
(define-const e2_00 Bool (= faulty #b10))
(define-const e2_01 Bool (= faulty #b11))
(define-const e2_10 Bool (= faulty #b00))
(define-const e2_11 Bool (= faulty #b01))

(define-const result2 (_ BitVec 32) 
    (MBWMAC a_h a_l b_h b_l INV2 e2_00 e2_01 e2_10 e2_11 SP2)
)

(echo "[INFO] When a unit is faulty proving that computation is equivalent to FP")
;(assert (not (= (bvadd result result2) (FP a_h a_l b_h b_l)))) ; => to difficult check simpler property
(echo "[INFO] The first computation is correct when M00 is faulty, should be UNSAT and it is:")
(push)
(assert (= faulty #b00)) 
(assert 
   (not 
        (= 
            (FP a_h a_l b_h b_l) 
            (bvadd result (bvmul (ext8ToU32 a_l) (ext8ToU32 b_l)))
        )
    )
)  
;(check-sat) ;
(pop)
(echo "[INFO] The second computation is correct when M00 is faulty, should be UNSAT and it is:")
(push)
(assert (= faulty #b00)) 
(assert 
    (not 
        (= 
            result2 
            (bvmul (ext8ToU32 a_l) (ext8ToU32 b_l))
        )
    )
)  
;(check-sat) ;
(pop)
(echo "[INFO] The first computation is correct when M01 is faulty, should be UNSAT and it is:")
(push)
(assert (= faulty #b01)) 
(assert 
    (not 
        (= 
            (FP a_h a_l b_h b_l) 
            (bvadd result (bvshl (bvmul (ext8ToU32 a_l) (ext8ToS32 b_h)) #x00000008))
        )
    )
) 
;(check-sat) ; 
(pop)
(echo "[INFO] The second computation is correct when M01 is faulty, should be UNSAT and it is:")
(push)
(assert (= faulty #b01)) 
(assert 
    (not 
        (= 
            result2 
            (bvshl (bvmul (ext8ToU32 a_l) (ext8ToS32 b_h)) #x00000008)
        )
    )
)  
;(check-sat) ; 
(pop)

(echo "[INFO] The first computation is correct when M10 is faulty, should be UNSAT and it is:")
(push)
(assert (= faulty #b10))
(assert 
    (not 
        (= 
            (FP a_h a_l b_h b_l) 
            (bvadd result (bvshl (bvmul (ext8ToS32 a_h) (ext8ToU32 b_l)) #x00000008))
        )
    )
) 
;(check-sat) ; 
(pop)

(echo "[INFO] The second computation is correct when M10 is faulty, should be UNSAT and it is:")
(push)
(assert (= faulty #b10)) 
(assert 
    (not 
        (= 
            result2 
            (bvshl (bvmul (ext8ToS32 a_h) (ext8ToU32 b_l)) #x00000008)
        )
    )
)  
;(check-sat) ; 
(pop)

(echo "[INFO] The first computation is correct when M11 is faulty, should be UNSAT and it is:")
(push)
(assert (= faulty #b11)) 
(assert 
    (not 
        (= 
            (FP a_h a_l b_h b_l) 
            (bvadd result (bvshl (bvmul (ext8ToS32 a_h) (ext8ToS32 b_h)) #x00000010))
        )
    )
)
(check-sat)
(pop)

(echo "[INFO] The second computation is correct when M11 is faulty, should be UNSAT and it is:")
(push)
(assert (= faulty #b11)) 
(assert 
    (not 
        (= 
            result2 
            (bvshl (bvmul (ext8ToS32 a_h) (ext8ToS32 b_h)) #x00000010)
        )
    )
)  
(check-sat) ;
(pop)